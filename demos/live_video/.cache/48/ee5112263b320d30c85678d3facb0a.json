{"id":"node_modules/@tensorflow-models/pose-detection/shared/filters/keypoints_velocity_filter.ts","dependencies":[{"name":"C:\\xampp\\htdocs\\pose-detection\\demos\\live_video\\package.json","includedInParent":true,"mtime":1636721533250},{"name":"C:\\xampp\\htdocs\\pose-detection\\demos\\live_video\\.babelrc","includedInParent":true,"mtime":1634828519177},{"name":"./relative_velocity_filter","loc":{"line":14,"column":41},"parent":"C:\\xampp\\htdocs\\pose-detection\\demos\\live_video\\node_modules\\@tensorflow-models\\pose-detection\\shared\\filters\\keypoints_velocity_filter.ts","resolved":"C:\\xampp\\htdocs\\pose-detection\\demos\\live_video\\node_modules\\@tensorflow-models\\pose-detection\\shared\\filters\\relative_velocity_filter.ts"}],"generated":{"js":"\"use strict\";\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nexports.__esModule = true;\r\nvar relative_velocity_filter_1 = require(\"./relative_velocity_filter\");\r\n/**\r\n * A stateful filter that smoothes landmark values overtime.\r\n *\r\n * More specifically, it uses `RelativeVelocityFilter` to smooth every x, y, z\r\n * coordinates over time, which as result gives us velocity of how these values\r\n * change over time. With higher velocity it weights new values higher.\r\n */\r\n// ref:\r\n// https://github.com/google/mediapipe/blob/master/mediapipe/calculators/util/landmarks_smoothing_calculator.cc\r\nvar KeypointsVelocityFilter = /** @class */ (function () {\r\n    function KeypointsVelocityFilter(config) {\r\n        this.config = config;\r\n    }\r\n    KeypointsVelocityFilter.prototype.apply = function (keypoints, microSeconds, objectScale) {\r\n        var _this = this;\r\n        if (keypoints == null) {\r\n            this.reset();\r\n            return null;\r\n        }\r\n        // Get value scale as inverse value of the object scale.\r\n        // If value is too small smoothing will be disabled and keypoints will be\r\n        // returned as is.\r\n        var valueScale = 1;\r\n        if (!this.config.disableValueScaling) {\r\n            if (objectScale < this.config.minAllowedObjectScale) {\r\n                return keypoints.slice();\r\n            }\r\n            valueScale = 1 / objectScale;\r\n        }\r\n        // Initialize filters once.\r\n        this.initializeFiltersIfEmpty(keypoints);\r\n        // Filter keypoints. Every axis of every keypoint is filtered separately.\r\n        return keypoints.map(function (keypoint, i) {\r\n            var outKeypoint = __assign({}, keypoint, { x: _this.xFilters[i].apply(keypoint.x, microSeconds, valueScale), y: _this.yFilters[i].apply(keypoint.y, microSeconds, valueScale) });\r\n            if (keypoint.z != null) {\r\n                outKeypoint.z =\r\n                    _this.zFilters[i].apply(keypoint.z, microSeconds, valueScale);\r\n            }\r\n            return outKeypoint;\r\n        });\r\n    };\r\n    KeypointsVelocityFilter.prototype.reset = function () {\r\n        this.xFilters = null;\r\n        this.yFilters = null;\r\n        this.zFilters = null;\r\n    };\r\n    // Initializes filters for the first time or after reset. If initialized the\r\n    // check the size.\r\n    KeypointsVelocityFilter.prototype.initializeFiltersIfEmpty = function (keypoints) {\r\n        var _this = this;\r\n        if (this.xFilters == null || this.xFilters.length !== keypoints.length) {\r\n            this.xFilters =\r\n                keypoints.map(function (_) { return new relative_velocity_filter_1.RelativeVelocityFilter(_this.config); });\r\n            this.yFilters =\r\n                keypoints.map(function (_) { return new relative_velocity_filter_1.RelativeVelocityFilter(_this.config); });\r\n            this.zFilters =\r\n                keypoints.map(function (_) { return new relative_velocity_filter_1.RelativeVelocityFilter(_this.config); });\r\n        }\r\n    };\r\n    return KeypointsVelocityFilter;\r\n}());\r\nexports.KeypointsVelocityFilter = KeypointsVelocityFilter;\r\n"},"sourceMaps":{"js":{"version":3,"file":"keypoints_velocity_filter.js","sourceRoot":"","sources":["node_modules/@tensorflow-models/pose-detection/shared/filters/keypoints_velocity_filter.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAkBA,uEAAkE;AAElE;;;;;;GAMG;AACH,OAAO;AACP,+GAA+G;AAC/G;IAKE,iCAA6B,MAA4B;QAA5B,WAAM,GAAN,MAAM,CAAsB;IAAG,CAAC;IAE7D,uCAAK,GAAL,UAAM,SAAqB,EAAE,YAAoB,EAAE,WAAmB;QAAtE,iBAmCC;QAjCC,IAAI,SAAS,IAAI,IAAI,EAAE;YACrB,IAAI,CAAC,KAAK,EAAE,CAAC;YACb,OAAO,IAAI,CAAC;SACb;QACD,wDAAwD;QACxD,yEAAyE;QACzE,kBAAkB;QAClB,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,mBAAmB,EAAE;YACpC,IAAI,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,qBAAqB,EAAE;gBACnD,OAAW,SAAS,SAAE;aACvB;YACD,UAAU,GAAG,CAAC,GAAG,WAAW,CAAC;SAC9B;QAED,2BAA2B;QAC3B,IAAI,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC;QAEzC,yEAAyE;QACzE,OAAO,SAAS,CAAC,GAAG,CAAC,UAAC,QAAQ,EAAE,CAAC;YAC/B,IAAM,WAAW,gBACZ,QAAQ,IACX,CAAC,EAAE,KAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,YAAY,EAAE,UAAU,CAAC,EAC/D,CAAC,EAAE,KAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,YAAY,EAAE,UAAU,CAAC,GAChE,CAAC;YAEF,IAAI,QAAQ,CAAC,CAAC,IAAI,IAAI,EAAE;gBACtB,WAAW,CAAC,CAAC;oBACT,KAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,YAAY,EAAE,UAAU,CAAC,CAAC;aAClE;YAED,OAAO,WAAW,CAAC;QACrB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,uCAAK,GAAL;QACE,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;IACvB,CAAC;IAED,4EAA4E;IAC5E,kBAAkB;IACV,0DAAwB,GAAhC,UAAiC,SAAqB;QAAtD,iBASC;QARC,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,SAAS,CAAC,MAAM,EAAE;YACtE,IAAI,CAAC,QAAQ;gBACT,SAAS,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,IAAI,iDAAsB,CAAC,KAAI,CAAC,MAAM,CAAC,EAAvC,CAAuC,CAAC,CAAC;YAChE,IAAI,CAAC,QAAQ;gBACT,SAAS,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,IAAI,iDAAsB,CAAC,KAAI,CAAC,MAAM,CAAC,EAAvC,CAAuC,CAAC,CAAC;YAChE,IAAI,CAAC,QAAQ;gBACT,SAAS,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,IAAI,iDAAsB,CAAC,KAAI,CAAC,MAAM,CAAC,EAAvC,CAAuC,CAAC,CAAC;SACjE;IACH,CAAC;IACH,8BAAC;AAAD,CAAC,AA9DD,IA8DC;AA9DY,0DAAuB","sourcesContent":["/**\r\n * @license\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\nimport {Keypoint, KeypointsFilter} from '../calculators/interfaces/common_interfaces';\r\nimport {VelocityFilterConfig} from '../calculators/interfaces/config_interfaces';\r\nimport {RelativeVelocityFilter} from './relative_velocity_filter';\r\n\r\n/**\r\n * A stateful filter that smoothes landmark values overtime.\r\n *\r\n * More specifically, it uses `RelativeVelocityFilter` to smooth every x, y, z\r\n * coordinates over time, which as result gives us velocity of how these values\r\n * change over time. With higher velocity it weights new values higher.\r\n */\r\n// ref:\r\n// https://github.com/google/mediapipe/blob/master/mediapipe/calculators/util/landmarks_smoothing_calculator.cc\r\nexport class KeypointsVelocityFilter implements KeypointsFilter {\r\n  private xFilters: RelativeVelocityFilter[];\r\n  private yFilters: RelativeVelocityFilter[];\r\n  private zFilters: RelativeVelocityFilter[];\r\n\r\n  constructor(private readonly config: VelocityFilterConfig) {}\r\n\r\n  apply(keypoints: Keypoint[], microSeconds: number, objectScale: number):\r\n      Keypoint[] {\r\n    if (keypoints == null) {\r\n      this.reset();\r\n      return null;\r\n    }\r\n    // Get value scale as inverse value of the object scale.\r\n    // If value is too small smoothing will be disabled and keypoints will be\r\n    // returned as is.\r\n    let valueScale = 1;\r\n    if (!this.config.disableValueScaling) {\r\n      if (objectScale < this.config.minAllowedObjectScale) {\r\n        return [...keypoints];\r\n      }\r\n      valueScale = 1 / objectScale;\r\n    }\r\n\r\n    // Initialize filters once.\r\n    this.initializeFiltersIfEmpty(keypoints);\r\n\r\n    // Filter keypoints. Every axis of every keypoint is filtered separately.\r\n    return keypoints.map((keypoint, i) => {\r\n      const outKeypoint = {\r\n        ...keypoint,\r\n        x: this.xFilters[i].apply(keypoint.x, microSeconds, valueScale),\r\n        y: this.yFilters[i].apply(keypoint.y, microSeconds, valueScale),\r\n      };\r\n\r\n      if (keypoint.z != null) {\r\n        outKeypoint.z =\r\n            this.zFilters[i].apply(keypoint.z, microSeconds, valueScale);\r\n      }\r\n\r\n      return outKeypoint;\r\n    });\r\n  }\r\n\r\n  reset() {\r\n    this.xFilters = null;\r\n    this.yFilters = null;\r\n    this.zFilters = null;\r\n  }\r\n\r\n  // Initializes filters for the first time or after reset. If initialized the\r\n  // check the size.\r\n  private initializeFiltersIfEmpty(keypoints: Keypoint[]) {\r\n    if (this.xFilters == null || this.xFilters.length !== keypoints.length) {\r\n      this.xFilters =\r\n          keypoints.map(_ => new RelativeVelocityFilter(this.config));\r\n      this.yFilters =\r\n          keypoints.map(_ => new RelativeVelocityFilter(this.config));\r\n      this.zFilters =\r\n          keypoints.map(_ => new RelativeVelocityFilter(this.config));\r\n    }\r\n  }\r\n}\r\n"]}},"error":null,"hash":"f7f6c13a0693ab799c033a4719326494","cacheData":{"env":{}}}